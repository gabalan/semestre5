type 'a tree = Empty | Bin of 'a * 'a tree * 'a tree


let rec btree_size t=
  match t with
   Empty-> 0
   |Bin(x,g,d)->1+(btree_size g) +( btree_size d);;
   
   
  let rec btree_height t=
  match t with
    Empty-> -1
   |Bin(x,Empty,Empty)->0
   |Bin(x,g,d)->1+ max ( btree_height g)( btree_height d);;

 

let rec nbfeuilles t=
  match t with
    Empty-> 0
   |Bin(x,Empty,Empty)-> 1
   |Bin(x,g,d)->( nbfeuilles g) + (nbfeuilles d)


let rec arity1 t=
  match t with
    Empty->0
   |Bin(x,Empty,Empty)->0
   |Bin(x,Empty,d)->1+arity1 d
   |Bin(x,g,Empty)->1+arity1 g
   |Bin(x,g,d)->arity1 g +arity1 d

let rec arity2 t=
  match t with
     Empty->0
   |Bin(x,Empty,Empty)->0
   |Bin(x,Empty,d)->arity2 d
   |Bin(x,g,Empty)->arity2 g
   |Bin(x,g,d)->1+ arity2 g +arity2 d
    
let rec parameters t =
  match t with
   |Empty -> (0,0,0,0,-1)
   |Bin(x,g,d)-> let s= btree_size t in
                 let a1 = arity1 t in
                 let a2=arity2 t in
                 let h=btree_height t in
                 let f= nbfeuilles t in
                     (s,f,a1,a2,h)


  let rec btree_height t=
  match t with
    Empty-> -1
   |Bin(x,Empty,Empty)->0
   |Bin(x,g,d)->1+ max ( btree_height g)( btree_height d);;

let rec is_perfect t = 
    match t with
    Empty->true
    |Bin(x,Empty,Empty)->true
    |Bin(x,g,Empty)->false
    |Bin(x,Empty,d)->false
    |Bin(x,g,d)->(btree_height g=btree_height d) && (is_perfect g) && (is_perfect d)

let rec is_quasi_perfect t = 
    match t with
    Empty-> true
    |Bin(x,Empty,Empty) -> true
    |Bin(x,g,Empty) -> if (btree_height t > 1 ) then false else is_quasi_perfect g
    |Bin(x,Empty,d)-> false
    |Bin(x,g,d) -> (is_perfect g && is_perfect d) || (is_quasi_perfect g) || (is_quasi_perfect d )
let t1 = Bin (91, Bin (17, Bin (21, Empty, Empty), Bin (20, Empty, Empty)), Empty)

let rec superieur t n =
  match t with
  |Empty -> 0
  |Bin(x,tg,td) -> if (n < x) then 1+(superieur tg n)+ (superieur td n)
                   else (superieur tg n)+ (superieur td n)
                     
