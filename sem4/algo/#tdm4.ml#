(* Binary tree with leaves carÂ­rying an integer. *)
type bintree = Empty | Node of int * bintree * bintree;;

let t = Node(1, Node(2, Node(4, Empty, Empty), Node(5, Node(7, Empty, Empty), Node(8, Empty, Empty))), Node(3,Empty,Node(6, Node(9, Empty, Empty), Empty)));;

let rec bintree_count_nodes = function
  | Empty         -> 0
  | Node(_, l, r) -> 1 + bintree_count_nodes l + bintree_count_nodes r;;

let rec noeud t=
  match t with
    Empty->0
   |Node(x,g,d)->1+noeud g +noeud d
                                  
let rec noeud2 t=
  match t with
    Empty->0
  |Node(x,Empty,Empty)->1
   |Node(x,g,d)->noeud2 g +noeud2 d

  let rec noeud3 t=
  match t with
    Empty->0
  |Node(x,Empty,Empty)->0
  |Node(x,g,d)->1+noeud3 g +noeud3 d

  let rec hauteur t=
    match t with
      Empty-> -1
     |Node(x,Empty,Empty)->0
     |Node(x,g,d)->1+max (hauteur g) (hauteur d)
  let rec mirror t1 t2=
    
    
let rec bintree_count_leaves = function
  | Empty                 -> 0
  | Node(_, Empty, Empty) -> 1
  | Node(_, l, r)         -> bintree_count_leaves l + bintree_count_leaves r;;

let rec bintree_count_internal_nodes = function
  | Empty                 -> 0
  | Node(_, Empty, Empty) -> 0
  | Node(_, l, r)         -> 1 + bintree_count_internal_nodes l + bintree_count_internal_nodes r;;

let rec bintree_height = function
  | Empty -> 0
  | Node(_, l, r) -> 1 + max (bintree_height l) (bintree_height r);;

let rec bintree_is_mirror t1 t2 =
  match t1, t2 with
  | Empty, Empty                     -> true
  | Node(_, l1, r1), Node(_, l2, r2) -> bintree_is_mirror l1 r2 && bintree_is_mirror r1 l2
  | _                                -> false;;

let bintree_is_symmetric = function
  | Empty         -> true
  | Node(_, l, r) -> bintree_is_mirror l r;;

let rec bintree_collect_nodes = function
  | Empty         -> []
  | Node(i, l, r) -> [i] @  (bintree_collect_nodes l) @ (bintree_collect_nodes r);;

let rec bintree_collect_leaves = function
  | Empty                 -> []
  | Node(i, Empty, Empty) -> [i]
  | Node(_, l, r)         -> (bintree_collect_leaves l) @ (bintree_collect_leaves r);;

(* let rec bintree_collect_internal_nodes = function
  | Empty                 -> []
  | Node(_, Empty, Empty) -> []
  | Node(i, l, r)         -> [i] @  (bintree_collect_internal_nodes l) @ (bintree_collect_internal_nodes r);; *)

let rec bintree_collect_internal_nodes = function
  | Empty   
  | Node(_, Empty, Empty) -> []
  | Node(i, l, r)         -> [i] @  (bintree_collect_internal_nodes l) @ (bintree_collect_internal_nodes r);;


let rec bintree_collect_level t l = match t with
  | Empty -> []
  | Node(c, left, right) -> if l = 1 then [c] else bintree_collect_level left (l - 1) @ bintree_collect_level right (l - 1);;

let rec bintree_visit_pre = function
  | Empty         -> []
  | Node(i, l, r) -> [i] @ (bintree_visit_pre l) @ (bintree_visit_pre r);;

let rec bintree_visit_post = function
  | Empty         -> []
  | Node(i, l, r) -> (bintree_visit_post l) @ (bintree_visit_post r) @ [i];;

let rec bintree_visit_in = function
  | Empty         -> []
  | Node(i, l, r) -> (bintree_visit_in l) @ [i] @ (bintree_visit_in r);;

let rec bintree_insert t x = match t with
  | Empty         -> Node(x, Empty, Empty)
  | Node(i, l, r) -> if x <= i then Node(i, bintree_insert l x, r) else Node(i, l, bintree_insert r x);;

let rec bintree_search t x = match t with
  | Empty         -> false
  | Node(i, l, r) -> if i == x then true else if x < i then bintree_search l x else bintree_search r x;;

let rec bintree_double = function
  | Empty         -> Empty
  | Node(i, l, r) -> Node(2*i, bintree_double l, bintree_double r);;

let rec bintree_apply t f = match t with
  | Empty         -> Empty
  | Node(i, l, r) -> Node(f i, bintree_apply l f, bintree_apply r f);;

let rec bintree_rotate = function
  | Empty -> Empty
  | Node(i, l, r) -> Node(i, bintree_rotate r, bintree_rotate l);;

let rec bintree_sum_subtree = function
  | Empty -> Empty
  | Node(i, l, r) -> let l' = bintree_sum_subtree l and r' = bintree_sum_subtree r in
                     match l', r' with
                     | Empty, Empty                 -> Node(i, l', r')
                     | Empty, Node(k, _, _)         -> Node(i + k, l', r')
                     | Node(j, _, _), Empty         -> Node(i + j, l', r')
                     | Node(j, _, _), Node(k, _, _) -> Node(i + j + k, l', r');;


